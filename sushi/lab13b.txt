老师在课件中给的思路是贪心+动态规划。这一题贪心的部分在于从高位开始，检查answer加上**每一位**后是否仍然存在某种划分方式使得各个区间的*bitwise AND*结果为answer. 贪心的点在于应该从最高位开始找起，考虑一下这题最大的答案大概有$answer\approx 2^{56}$. 所以记得开long. 

关于判断某个答案是否满足**要求**，需要用到动态规划（当然有暴力的做法，本地试了一下极限数据时间上过不去，oj上应该可以做到60tle(我没试过)，但听说有人20wa）。定义我们的子问题$OPT[i][j]$的值代表前$i$个数字被分成$j$个子数组能否满足**要求**，那么转移方程大概长这样：$OPT[i][j] =$(前$t$个($t<i$)元素组成的$j-1$个子数组能满足要求)&&(第$t$到第$i$个元素组成的第$j$个子数组和当前答案*bitwise AND*结果和当前答案相等). 我们需要的结果就是$OPT[n][k]$. 这表示$n$个元素分成$k$个子数组后能满足要求。

ps: **要求**指各个子数组*bitwise AND*结果为当前答案。

pss: 以样例为例，逐位检查答案的过程大概是这样的：<br/>
check(100...000) = false, answer = 0<br/>
check(010...000) = false, answer = 0<br/>
check(001...000) = false, answer = 0<br/>
...<br/>
check(00...100000) = false, answer = 0<br/>
check(00...010000) = true, answer = 10000<br/>
check(00...011000) = true, answer = 11000<br/>
check(00...011100) = false, answer = 11000<br/>
check(00...011010) = false, answer = 11000<br/>
check(00...011001) = false, answer = 11000<br/>
由此，最终的得到的答案为$11000_2=24_{10}$.

psss: lab=30%, final exam=40%. lab < final exam.

pssss: 一学期下来，感觉还是听lanran讲故事睡得香，尽管这些故事和题目联系并不是特别紧密。

