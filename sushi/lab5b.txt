到饭点了，好饿。想起来晚上讲座啥都没吃上……

考虑这样一棵树 $V = \{1,2,3\}$, $E = \{1-2, 1-3\}$. 其中$1$、$2$、$3$的果子分别为$0$、$3$、$6$，$1-2$的边权为$3$, $1-3$的边权为$3$. 很容易想到这时候应该先走$1-3$再走$1-2$. 这样选择需要等待的时间就为$3$. 考虑另外一条路，等待时间为$6$,但结束后回到根节点剩余$3$的HP（这时候似乎发现了一点：要让等待的时间最短和让回到起点时的剩余HP最少其实是等价的）。

稍微添加一点节点，考虑一个稍复杂一点的情况：$V = \{1,2,3,4,5\}$, $A = \{0,2,3,3,1\}$, $E = \{1-2, 1-5, 2-3, 2-4\}$, $W = \{2,1,1,1\}$. 先看以$2$为根的子树，可以得到遍历完这棵树HP会增加$4$，算上边$1-2$,从$1$选择走$1-2$共计损失$2$点HP. 考虑另一条路，损失是$1$，这种情况下应先选择损失大的。可以算出，先选择$1-2$耗时为$3$，剩余HP为$0$,另一条路耗时为$4$.剩余HP为$1$.

将上一个例子的权值稍作修改$V = \{1,2,3,4,5\}$, $A = \{0,2,3,3,\textbf{0}\}$, $E = \{1-2, 1-5, 2-3, 2-4\}$, $W = \{2,1,1,1\}$. 这时候从根节点出发的两条路径都是损失$2$HP了，在损失相同的情况下，应该优先选择边权小的，可以算出，先选择$1-2$耗时为$4$，剩余HP为$0$；另一条路耗时为$5$，剩余HP为$1$.

总的来说，就是递归地计算子树的损失，然后排序（损失相同时比较边权），回溯的时候把答案带上就ok啦！

ps：边吃夜宵边写的…还没有验证正不正确，边吃边敲代码边写的思路…欢迎dl指点。

pss：茶歇真的好馋。



将一棵子树视作一个节点来处理，只关心第一层各个子树的访问顺序对剩余HP的影响（认为根节点是第零层）。

维护三个数组investment、income、pure_income(大小都开成节点数量即可)。一次dfs，入栈的时候仅更新investment(investment[node] = weight[node $\leftarrow$ from])，若是叶子节点，则分别计算income和pure_income. 在出栈时，用该节点的HP以及investment结合其所有子节点的income和pure_income计算其相应的income和pure_income, 直至返回到根节点。这个时候对于根节点的所有子节点先分类后排序:
$$
pure\_income
\left\{  
             \begin{array}{lr} 
             >0
\left\{  
             \begin{array}{lr}  
             small-invesetment &    \\
             large-invesetment &    \\
             \end{array}  
\right.  
   \\
             <0
\left\{  
             \begin{array}{lr}  
             large-income &    \\
             small-income &    \\  
             \end{array}  
\right.  
   
             \end{array}  
\right.  
$$
接下来只需要按顺序(按上面那个从上往下，详情参考lab课件)模拟遍历这每一个"子节点" (子树)的过程，就可以得出最后的答案。

ps: 记得long.

pss: 和dl对拍的时候出了点小意外，但是似乎能混过OJ，谨慎参考orz。