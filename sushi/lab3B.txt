取字符串每两个相邻字符作为建图的依据，如果两个都是非元音字母，那么这两个节点之间的边权加一，如果至少其一为元音字母则不做处理。记录下所有出现过的非元音字母。 读取数据时间O（n）

1.时间复杂度O(c^2 \times 2^c),结果 60% tle.

考虑枚举每一个非元音字母的大小写情况（共计2^c种情况），在每种情况下找出所有大小写状态不同的字母之间的边权加和O(c^2)，维护最大值。检索完所有情况后输出最大值。

2.时间复杂度O(c \times 2^c)，结果 我也没试过，应该能过。

与1不同的地方在于维护最大值的过程：考虑出现字母为bcdf，那么在计算BCdF的答案时，可以用BCdf的答案加F与所有节点的边权和（预处理好O（c^2）,作为常数项约去）减去f与每个当前为大写的字母节点的边权之和（B-f,C-f）的两倍。这样的在每种情况下的检索可以做到O（c），总时间复杂度O(c \times 2^c)。

3.时间复杂度O(c \times 2^（c-1）)，结果 ac.

在2的基础上加一点点优化，已知所有字母都是大写或者所有字母都是小写的情况下，value一定是0，不用考虑。

*Hint:枚举每一种过程的方法，考虑一个二进制数（2^c），某一位为1的时候相当于这个位置对应的数是大写的，反之为小写的。用位运算可以轻松得出每一种情况。

**c指的是出现非元音字母的个数；